;library_id;library_name;vulnerability_id;description;Details in description?;Language;Project language;Affected class/file;Affected method;CWE;Type;Type by me;Comments;Has fix link;Fix link;baseSeverity;privilegesRequired;userInteractionRequired;confidentialityImpact;relatedCPE;attackComplexity;scope;attackVector;integrityImpact;publishedDate
0;55742;ibm-swift/kitura;CVE-2018-1000181;en: Kitura 2.3.0 and earlier have an unintended read access to unauthorised files and folders that can be exploited by a crafted URL resulting in information disclosure.;FALSE;Swift;Swift;StaticFileServer.swift, FileServer.swift, Router.swift, FileResourceServer.swift;;CWE-200;Missing sanitation;TRUE;;TRUE;https://github.com/Kitura/Kitura/pull/1278;HIGH;NONE;NONE;HIGH;cpe:2.3:a:ibm:kitura:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2018-06-05T13:29Z
139;253880;k-takata/onigmo;CVE-2019-16162;en: Onigmo through 6.2.0 has an out-of-bounds read in parse_char_class because of missing codepoint validation in regenc.c.;TRUE;C;C;regenc.c;parse_char_class ;CWE-125;Out-of-bounds read;FALSE;Only if single byte encoding used;TRUE;https://github.com/k-takata/Onigmo/issues/139;HIGH;NONE;NONE;NONE;cpe:2.3:a:k-takata:onigmo:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-09-09T17:15Z
187;253836;k-takata/onigmo;CVE-2019-16161;en: Onigmo through 6.2.0 has a NULL pointer dereference in onig_error_code_to_str because of fetch_token in regparse.c.;TRUE;C;C;regparse.c;onig_error_code;CWE-476;NULL Pointer Dereference;FALSE;;TRUE;https://github.com/k-takata/Onigmo/commit/9827d5a0298ee766f6041db9c0080166ff6cdce8;HIGH;NONE;NONE;NONE;cpe:2.3:a:k-takata:onigmo:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-09-09T17:15Z
235;1204887;libevent/libevent;CVE-2016-10195;en: The name_parse function in evdns.c in libevent before 2.1.6-beta allows remote attackers to have unspecified impact via vectors involving the label_len variable, which triggers an out-of-bounds stack read.;TRUE;C;C;evdns.c;name_parse;CWE-125;Out-of-bounds Read;FALSE;;TRUE;https://github.com/libevent/libevent/commit/96f64a022014a208105ead6c8a7066018449d86d;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:libevent_project:libevent:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2017-03-15T15:59Z
288;1204832;libevent/libevent;CVE-2016-10197;en: The search_make_new function in evdns.c in libevent before 2.1.6-beta allows attackers to cause a denial of service (out-of-bounds read) via an empty hostname.;TRUE;C;C;evdns.c;search_make_new;CWE-125;Out-of-bounds Read;FALSE;;TRUE;https://github.com/libevent/libevent/commit/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e;HIGH;NONE;NONE;NONE;cpe:2.3:a:libevent_project:libevent:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2017-03-15T15:59Z
341;1204961;libevent/libevent;CVE-2016-10196;en: Stack-based buffer overflow in the evutil_parse_sockaddr_port function in evutil.c in libevent before 2.1.6-beta allows attackers to cause a denial of service (segmentation fault) via vectors involving a long string in brackets in the ip_as_string argument.;TRUE;C;C;evutil.c;evutil_parse_sockaddr_port;CWE-125;Out-of-bounds Read;FALSE;crash on ASAN-protected builds;TRUE;https://github.com/libevent/libevent/commit/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e;HIGH;NONE;NONE;NONE;cpe:2.3:a:libevent_project:libevent:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2017-03-15T15:59Z
394;1205005;libevent/libevent;CVE-2014-6272;"en: Multiple integer overflows in the evbuffer API in Libevent 1.4.x before 1.4.15, 2.0.x before 2.0.22, and 2.1.x before 2.1.5-beta allow context-dependent attackers to cause a denial of service or possibly have other unspecified impact via ""insanely large inputs"" to the (1) evbuffer_add, (2) evbuffer_expand, or (3) bufferevent_write function, which triggers a heap-based buffer overflow or an infinite loop.  NOTE: this identifier has been SPLIT per ADT3 due to different affected versions. See CVE-2015-6525 for the functions that are only affected in 2.0 and later.";TRUE;C;C; evbuffer API (buffer.h);evbuffer_add, evbuffer_expand, bufferevent_write;CWE-189;Numeric Errors;FALSE;;FALSE;;;;;;cpe:2.3:a:libevent_project:libevent:*:*:*:*:*:*:*:*;;;;;2015-08-24T14:59Z
435;1204995;libevent/libevent;CVE-2015-6525;"en: Multiple integer overflows in the evbuffer API in Libevent 2.0.x before 2.0.22 and 2.1.x before 2.1.5-beta allow context-dependent attackers to cause a denial of service or possibly have other unspecified impact via ""insanely large inputs"" to the (1) evbuffer_add, (2) evbuffer_prepend, (3) evbuffer_expand, (4) exbuffer_reserve_space, or (5) evbuffer_read function, which triggers a heap-based buffer overflow or an infinite loop.  NOTE: this identifier was SPLIT from CVE-2014-6272 per ADT3 due to different affected versions.";TRUE;C;C; evbuffer API (buffer.h);evbuffer_add, evbuffer_prepend, evbuffer_expand, exbuffer_reserve_space, evbuffer_read;CWE-189;Numeric Errors;FALSE;;FALSE;;;;;;cpe:2.3:a:libevent_project:libevent:*:*:*:*:*:*:*:*;;;;;2015-08-24T14:59Z
460;11213;google/protobuf;CVE-2021-22570;en: Nullptr dereference when a null char is present in a proto symbol. The symbol is parsed incorrectly, leading to an unchecked call into the proto file's name during generation of the resulting error message. Since the symbol is incorrectly parsed, the file is nullptr. We recommend upgrading to version 3.15.0 or greater.;FALSE;;C++;;;CWE-476;"NULL Pointer Dereference
";FALSE;;FALSE;;HIGH;NONE;NONE;NONE;cpe:2.3:a:google:protobuf:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2022-01-26T14:15Z
547;1055559;apache/cordova-plugin-file-transfer;CVE-2015-5204;en: CRLF injection vulnerability in the Apache Cordova File Transfer Plugin (cordova-plugin-file-transfer) for Android before 1.3.0 allows remote attackers to inject arbitrary headers via CRLF sequences in the filename of an uploaded file.;FALSE;;JavaScript;;;;;;;;;;;;;cpe:2.3:a:apache:cordova_file_transfer:*:*:*:*:*:android:*:*;;;;;2015-12-17T19:59Z
562;1055955;apache/cordova-plugin-inappbrowser;CVE-2014-0073;en: The CDVInAppBrowser class in the Apache Cordova In-App-Browser standalone plugin (org.apache.cordova.inappbrowser) before 0.3.2 for iOS and the In-App-Browser plugin for iOS from Cordova 2.6.0 through 2.9.0 does not properly validate callback identifiers, which allows remote attackers to execute arbitrary JavaScript in the host page and consequently gain privileges via a crafted gap-iab: URI.;FALSE;;JavaScript;;;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:apache:cordova_in-app-browser:*:*:*:*:*:iphone_os:*:*;LOW;UNCHANGED;NETWORK;HIGH;2017-10-30T19:29Z
569;210442;grpc/grpc-swift;CVE-2021-36155;en: LengthPrefixedMessageReader in gRPC Swift 1.1.0 and earlier allocates buffers of arbitrary length, which allows remote attackers to cause uncontrolled resource consumption and deny service.;TRUE;Swift;Swift;LengthPrefixedMessageReader;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:linuxfoundation:grpc_swift:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-07-09T12:15Z
594;210418;grpc/grpc-swift;CVE-2021-36154;en: HTTP2ToRawGRPCServerCodec in gRPC Swift 1.1.1 and earlier allows remote attackers to deny service via the delivery of many small messages within a single HTTP/2 frame, leading to Uncontrolled Recursion and stack consumption.;TRUE;Swift;Swift;HTTP2ToRawGRPCServerCodec;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:linuxfoundation:grpc_swift:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-07-09T12:15Z
620;210465;grpc/grpc-swift;CVE-2021-36153;en: Mismanaged state in GRPCWebToHTTP2ServerCodec.swift in gRPC Swift 1.1.0 and 1.1.1 allows remote attackers to deny service by sending malformed requests.;TRUE;Swift;Swift;GRPCWebToHTTP2ServerCodec.swift;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:linuxfoundation:grpc_swift:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-07-09T12:15Z
622;177545;swisspol/gcdwebserver;CVE-2019-14924;en: An issue was discovered in GCDWebServer before 3.5.3. The method moveItem in the GCDWebUploader class checks the FileExtension of newAbsolutePath but not oldAbsolutePath. By leveraging this vulnerability, an adversary can make an inaccessible file be available (the credential of the app, for instance).;TRUE;Objective-C;Objective-C;GCDWebUploader;moveItem;;;;;;;HIGH;NONE;NONE;HIGH;cpe:2.3:a:gcdwebserver_project:gcdwebserver:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-08-10T19:15Z
664;1146580;vapor/vapor;CVE-2021-32742;en: Vapor is a web framework for Swift. In versions 4.47.1 and prior, bug in the `Data.init(base32Encoded:)` function opens up the potential for exposing server memory and/or crashing the server (Denial of Service) for applications where untrusted data can end up in said function. Vapor does not currently use this function itself so this only impact applications that use the impacted function directly or through other dependencies. The vulnerability is patched in version 4.47.2. As a workaround, one may use an alternative to Vapor's built-in `Data.init(base32Encoded:)`.;TRUE;Swift;Swift;;Data.init(base32Encoded:);;;;Vapor does not currently use this function itself so this only impact applications that use the impacted function directly or through other dependencies. ;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:vapor_project:vapor:*:*:*:*:*:swift:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-07-09T14:15Z
667;991458;vapor/vapor;CVE-2021-21328;en: Vapor is a web framework for Swift. In Vapor before version 4.40.1, there is a DoS attack against anyone who Bootstraps a metrics backend for their Vapor app. The following is the attack vector: 1. send unlimited requests against a vapor instance with different paths. this will create unlimited counters and timers, which will eventually drain the system. 2. downstream services might suffer from this attack as well by being spammed with error paths. This has been patched in 4.40.1. The `DefaultResponder` will rewrite any undefined route paths for to `vapor_route_undefined` to avoid unlimited counters.;FALSE;Swift;Swift;;;;;;DoS attack against anyone who Bootstraps a metrics backend for their Vapor app;;;MEDIUM;NONE;NONE;NONE;cpe:2.3:a:vapor_project:vapor:*:*:*:*:*:swift:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-02-26T02:15Z
670;991495;vapor/vapor;CVE-2020-15230;en: Vapor is a web framework for Swift. In Vapor before version 4.29.4, Attackers can access data at arbitrary filesystem paths on the same host as an application. Only applications using FileMiddleware are affected. This is fixed in version 4.29.4.;TRUE;Swift;Swift;FileMiddleware;;;;;;;;MEDIUM;LOW;NONE;HIGH;cpe:2.3:a:vapor_project:vapor:*:*:*:*:*:swift:*:*;LOW;UNCHANGED;NETWORK;NONE;2020-10-02T19:15Z
673;1190285;ionic-team/cordova-plugin-ionic-webview;CVE-2018-16202;en: Directory traversal vulnerability in cordova-plugin-ionic-webview versions prior to 2.2.0 (not including 2.0.0-beta.0, 2.0.0-beta.1, 2.0.0-beta.2, and 2.1.0-0) allows remote attackers to access arbitrary files via unspecified vectors.;FALSE;;Objective-C;;;;;;;;;HIGH;NONE;NONE;HIGH;cpe:2.3:a:ionicframework:ionic_web_view:*:*:*:*:*:cordova:*:*;LOW;CHANGED;NETWORK;NONE;2019-01-09T23:29Z
692;1206976;libuv/libuv;CVE-2015-0278;en: libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.;FALSE;;C;;;;;;;;;;;;;cpe:2.3:a:libuv_project:libuv:*:*:*:*:*:*:*:*;;;;;2015-05-18T15:59Z
788;1221288;mongodb/mongo-c-driver;CVE-2018-16790;en: _bson_iter_next_internal in bson-iter.c in libbson 1.12.0, as used in MongoDB mongo-c-driver and other products, has a heap-based buffer over-read via a crafted bson buffer.;TRUE;C;C; bson-iter.c ;_bson_iter_next_internal;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:mongodb:libbson:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2018-09-10T05:29Z
789;217372;facebook/react-native;CVE-2020-1920;en: A regular expression denial of service (ReDoS) vulnerability in the validateBaseUrl function can cause the application to use excessive resources, become unresponsive, or crash. This was introduced in react-native version 0.59.0 and fixed in version 0.64.1.;TRUE;JavaScript;JavaScript;;validateBaseUrl;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:facebook:react-native:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-06-01T14:15Z
845;178550;afnetworking/afnetworking;CVE-2015-3996;en: The default AFSecurityPolicy.validatesDomainName configuration for AFSSLPinningModeNone in the AFNetworking framework before 2.5.3, as used in the ownCloud iOS Library, disables verification of a server hostname against the domain name in the subject's Common Name (CN) of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.;FALSE;;Objective-C;;;;;;Vulnerability due to default value;;;;;;;cpe:2.3:a:afnetworking_project:afnetworking:*:*:*:*:*:*:*:*;;;;;2015-10-27T16:59Z
893;1205613;libimobiledevice/libplist;CVE-2017-7982;en: Integer overflow in the plist_from_bin function in bplist.c in libimobiledevice/libplist before 2017-04-19 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted plist file.;TRUE;C;C;bplist.c;plist_from_bin;;;;;;;MEDIUM;NONE;REQUIRED;NONE;cpe:2.3:a:libimobiledevice:libplist:*:*:*:*:*:*:*:*;LOW;UNCHANGED;LOCAL;NONE;2017-04-20T14:59Z
913;1205605;libimobiledevice/libplist;CVE-2017-5545;en: The main function in plistutil.c in libimobiledevice libplist through 1.12 allows attackers to obtain sensitive information from process memory or cause a denial of service (buffer over-read) via Apple Property List data that is too short.;TRUE;C;C;plistutil.c;Main;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:libimobiledevice:libplist:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2017-01-21T01:59Z
932;1205627;libimobiledevice/libplist;CVE-2017-5209;en: The base64decode function in base64.c in libimobiledevice libplist through 1.12 allows attackers to obtain sensitive information from process memory or cause a denial of service (buffer over-read) via split encoded Apple Property List data.;TRUE;C;C;base64.c;base64decode;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:libimobiledevice:libplist:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2017-01-11T16:59Z
952;1205634;libimobiledevice/libplist;CVE-2017-5835;en: libplist allows attackers to cause a denial of service (large memory allocation and crash) via vectors involving an offset size of zero.;FALSE;;C;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:libimobiledevice:libplist:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2017-03-03T15:59Z
977;1205639;libimobiledevice/libplist;CVE-2017-5836;en: The plist_free_data function in plist.c in libplist allows attackers to cause a denial of service (crash) via vectors involving an integer node that is treated as a PLIST_KEY and then triggers an invalid free.;TRUE;C;C;plist.c;plist_free_data;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:libimobiledevice:libplist:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2017-03-03T15:59Z
1002;1205608;libimobiledevice/libplist;CVE-2017-5834;en: The parse_dict_node function in bplist.c in libplist allows attackers to cause a denial of service (out-of-bounds heap read and crash) via a crafted file.;TRUE;C;C;bplist.c;parse_dict_node;;;;;;;MEDIUM;NONE;REQUIRED;NONE;cpe:2.3:a:libimobiledevice:libplist:*:*:*:*:*:*:*:*;LOW;UNCHANGED;LOCAL;NONE;2017-03-03T15:59Z
1027;1152913;nanopb/nanopb;CVE-2021-21401;en: Nanopb is a small code-size Protocol Buffers implementation in ansi C. In Nanopb before versions 0.3.9.8 and 0.4.5, decoding a specifically formed message can cause invalid `free()` or `realloc()` calls if the message type contains an `oneof` field, and the `oneof` directly contains both a pointer field and a non-pointer field. If the message data first contains the non-pointer field and then the pointer field, the data of the non-pointer field is incorrectly treated as if it was a pointer value. Such message data rarely occurs in normal messages, but it is a concern when untrusted data is parsed. This has been fixed in versions 0.3.9.8 and 0.4.5. See referenced GitHub Security Advisory for more information including workarounds.;FALSE;C;C;;;;;;;;;HIGH;LOW;NONE;NONE;cpe:2.3:a:nanopb_project:nanopb:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2021-03-23T18:15Z
1075;1152855;nanopb/nanopb;CVE-2020-26243;en: Nanopb is a small code-size Protocol Buffers implementation. In Nanopb before versions 0.4.4 and 0.3.9.7, decoding specifically formed message can leak memory if dynamic allocation is enabled and an oneof field contains a static submessage that contains a dynamic field, and the message being decoded contains the submessage multiple times. This is rare in normal messages, but it is a concern when untrusted data is parsed. This is fixed in versions 0.3.9.7 and 0.4.4. The following workarounds are available: 1) Set the option `no_unions` for the oneof field. This will generate fields as separate instead of C union, and avoids triggering the problematic code. 2) Set the type of the submessage field inside oneof to `FT_POINTER`. This way the whole submessage will be dynamically allocated and the problematic code is not executed. 3) Use an arena allocator for nanopb, to make sure all memory can be released afterwards.;FALSE;C;C;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:nanopb_project:nanopb:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2020-11-25T17:15Z
1121;1152874;nanopb/nanopb;CVE-2020-5235;en: There is a potentially exploitable out of memory condition In Nanopb before 0.4.1, 0.3.9.5, and 0.2.9.4. When nanopb is compiled with PB_ENABLE_MALLOC, the message to be decoded contains a repeated string, bytes or message field and realloc() runs out of memory when expanding the array nanopb can end up calling `free()` on a pointer value that comes from uninitialized memory. Depending on platform this can result in a crash or further memory corruption, which may be exploitable in some cases. This problem is fixed in nanopb-0.4.1, nanopb-0.3.9.5, nanopb-0.2.9.4.;FALSE;C;C;;;;;;Compiled with PB_ENABLE_MALLOC;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:nanopb_project:nanopb:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2020-02-04T03:15Z
1161;1206370;libssh2/libssh2;CVE-2019-17498;en: In libssh2 v1.9.0 and earlier versions, the SSH_MSG_DISCONNECT logic in packet.c has an integer overflow in a bounds check, enabling an attacker to specify an arbitrary (out-of-bounds) offset for a subsequent memory read. A crafted SSH server may be able to disclose sensitive information or cause a denial of service condition on the client system when a user connects to the server.;TRUE;C;C;packet.c;SSH_MSG_DISCONNECT;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:libssh2:libssh2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-10-21T22:15Z
1203;1206362;libssh2/libssh2;CVE-2019-13115;en: In libssh2 before 1.9.0, kex_method_diffie_hellman_group_exchange_sha256_key_exchange in kex.c has an integer overflow that could lead to an out-of-bounds read in the way packets are read from the server. A remote attacker who compromises a SSH server may be able to disclose sensitive information or cause a denial of service condition on the client system when a user connects to the server. This is related to an _libssh2_check_length mistake, and is different from the various issues fixed in 1.8.1, such as CVE-2019-3855.;TRUE;C;C;kex.c;kex_method_diffie_hellman_group_exchange_sha256_key_exchange;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:libssh2:libssh2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-07-16T18:15Z
1244;1206430;libssh2/libssh2;CVE-2019-3856;en: An integer overflow flaw, which could lead to an out of bounds write, was discovered in libssh2 before 1.8.1 in the way keyboard prompt requests are parsed. A remote attacker who compromises a SSH server may be able to execute code on the client system when a user connects to the server.;FALSE;C;C;;;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:libssh2:libssh2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2019-03-25T19:29Z
1283;1206373;libssh2/libssh2;CVE-2019-3857;en: An integer overflow flaw which could lead to an out of bounds write was discovered in libssh2 before 1.8.1 in the way SSH_MSG_CHANNEL_REQUEST packets with an exit signal are parsed. A remote attacker who compromises a SSH server may be able to execute code on the client system when a user connects to the server.;FALSE;C;C;;;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:libssh2:libssh2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2019-03-25T19:29Z
1322;1206358;libssh2/libssh2;CVE-2019-3855;en: An integer overflow flaw which could lead to an out of bounds write was discovered in libssh2 before 1.8.1 in the way packets are read from the server. A remote attacker who compromises a SSH server may be able to execute code on the client system when a user connects to the server.;FALSE;C;C;;;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:libssh2:libssh2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2019-03-21T21:29Z
1361;1206297;libssh2/libssh2;CVE-2019-3859;en: An out of bounds read flaw was discovered in libssh2 before 1.8.1 in the _libssh2_packet_require and _libssh2_packet_requirev functions. A remote attacker who compromises a SSH server may be able to cause a Denial of Service or read data in the client memory.;TRUE;C;C;;_libssh2_packet_require, _libssh2_packet_requirev ;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:libssh2:libssh2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-03-21T16:01Z
1400;1206439;libssh2/libssh2;CVE-2019-3863;en: A flaw was found in libssh2 before 1.8.1. A server could send a multiple keyboard interactive response messages whose total length are greater than unsigned char max characters. This value is used as an index to copy memory causing in an out of bounds memory write error.;FALSE;C;C;;;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:libssh2:libssh2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2019-03-25T18:29Z
1439;1206314;libssh2/libssh2;CVE-2019-3862;en: An out of bounds read flaw was discovered in libssh2 before 1.8.1 in the way SSH_MSG_CHANNEL_REQUEST packets with an exit status message and no payload are parsed. A remote attacker who compromises a SSH server may be able to cause a Denial of Service or read data in the client memory.;FALSE;C;C;;;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:libssh2:libssh2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-03-21T16:01Z
1478;1206326;libssh2/libssh2;CVE-2019-3861;en: An out of bounds read flaw was discovered in libssh2 before 1.8.1 in the way SSH packets with a padding length value greater than the packet length are parsed. A remote attacker who compromises a SSH server may be able to cause a Denial of Service or read data in the client memory.;FALSE;C;C;;;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:libssh2:libssh2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-03-25T19:29Z
1517;1206386;libssh2/libssh2;CVE-2019-3860;en: An out of bounds read flaw was discovered in libssh2 before 1.8.1 in the way SFTP packets with empty payloads are parsed. A remote attacker who compromises a SSH server may be able to cause a Denial of Service or read data in the client memory.;FALSE;C;C;;;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:libssh2:libssh2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-03-25T19:29Z
1556;1206439;libssh2/libssh2;CVE-2019-3858;en: An out of bounds read flaw was discovered in libssh2 before 1.8.1 when a specially crafted SFTP packet is received from the server. A remote attacker who compromises a SSH server may be able to cause a Denial of Service or read data in the client memory.;FALSE;C;C;;;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:libssh2:libssh2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-03-21T21:29Z
1595;1206358;libssh2/libssh2;CVE-2016-0787;"en: The diffie_hellman_sha256 function in kex.c in libssh2 before 1.7.0 improperly truncates secrets to 128 or 256 bits, which makes it easier for man-in-the-middle attackers to decrypt or intercept SSH sessions via unspecified vectors, aka a ""bits/bytes confusion bug.""";TRUE;C;C;kex.c;diffie_hellman_sha256;;;;;;;MEDIUM;NONE;NONE;HIGH;cpe:2.3:a:libssh2:libssh2:*:*:*:*:*:*:*:*;HIGH;UNCHANGED;NETWORK;NONE;2016-04-13T17:59Z
1632;1206344;libssh2/libssh2;CVE-2015-1782;en: The kex_agree_methods function in libssh2 before 1.5.0 allows remote servers to cause a denial of service (crash) or have other unspecified impact via crafted length values in an SSH_MSG_KEXINIT packet.;TRUE;C;C;;kex_agree_methods;;;;;;;;;;;cpe:2.3:a:libssh2:libssh2:*:*:*:*:*:*:*:*;;;;;2015-03-13T14:59Z
1668;1212966;jbeder/yaml-cpp;CVE-2019-6285;en: The SingleDocParser::HandleFlowSequence function in yaml-cpp (aka LibYaml-C++) 0.6.2 allows remote attackers to cause a denial of service (stack consumption and application crash) via a crafted YAML file.;TRUE;C++;C++;SingleDocParser;HandleFlowSequence;;;;;;;MEDIUM;NONE;REQUIRED;NONE;cpe:2.3:a:yaml-cpp_project:yaml-cpp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-01-14T22:29Z
1669;1212966;jbeder/yaml-cpp;CVE-2019-6292;en: An issue was discovered in singledocparser.cpp in yaml-cpp (aka LibYaml-C++) 0.6.2. Stack Exhaustion occurs in YAML::SingleDocParser, and there is a stack consumption problem caused by recursive stack frames: HandleCompactMap, HandleMap, HandleFlowSequence, HandleSequence, HandleNode. Remote attackers could leverage this vulnerability to cause a denial-of-service via a cpp file.;TRUE;C++;C++;singledocparser.cpp ;YAML::SingleDocParser;;;;;;;MEDIUM;NONE;REQUIRED;NONE;cpe:2.3:a:yaml-cpp_project:yaml-cpp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-01-15T00:29Z
1670;1212900;jbeder/yaml-cpp;CVE-2017-11692;"en: The function ""Token& Scanner::peek"" in scanner.cpp in yaml-cpp 0.5.3 and earlier allows remote attackers to cause a denial of service (assertion failure and application exit) via a '!2' string.";TRUE;C++;C++;scanner.cpp;Token& Scanner::peek;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:yaml-cpp_project:yaml-cpp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2017-07-30T17:29Z
1683;1212966;jbeder/yaml-cpp;CVE-2018-20573;en: The Scanner::EnsureTokensInQueue function in yaml-cpp (aka LibYaml-C++) 0.6.2 allows remote attackers to cause a denial of service (stack consumption and application crash) via a crafted YAML file.;TRUE;C++;C++;;Scanner::EnsureTokensInQueue;;;;;;;MEDIUM;NONE;REQUIRED;NONE;cpe:2.3:a:yaml-cpp_project:yaml-cpp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2018-12-28T16:29Z
1684;1212966;jbeder/yaml-cpp;CVE-2018-20574;en: The SingleDocParser::HandleFlowMap function in yaml-cpp (aka LibYaml-C++) 0.6.2 allows remote attackers to cause a denial of service (stack consumption and application crash) via a crafted YAML file.;TRUE;C++;C++;;SingleDocParser::HandleFlowMap;;;;;;;MEDIUM;NONE;REQUIRED;NONE;cpe:2.3:a:yaml-cpp_project:yaml-cpp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2018-12-28T16:29Z
1685;1212950;jbeder/yaml-cpp;CVE-2017-5950;en: The SingleDocParser::HandleNode function in yaml-cpp (aka LibYaml-C++) 0.5.3 allows remote attackers to cause a denial of service (stack consumption and application crash) via a crafted YAML file.;TRUE;C++;C++;;SingleDocParser::HandleNode;;;;;;;MEDIUM;NONE;REQUIRED;NONE;cpe:2.3:a:yaml-cpp_project:yaml-cpp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;LOCAL;NONE;2017-04-03T05:59Z
1686;1070769;apple/swift-nio;CVE-2019-9517;"en: Some HTTP/2 implementations are vulnerable to unconstrained interal data buffering, potentially leading to a denial of service. The attacker opens the HTTP/2 window so the peer can send without constraint; however, they leave the TCP window closed so the peer cannot actually write (many of) the bytes on the wire. The attacker then sends a stream of requests for a large response object. Depending on how the servers queue the responses, this can consume excess memory, CPU, or both.";FALSE;;Swift;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:apple:swiftnio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-08-13T21:15Z
1697;1070769;apple/swift-nio;CVE-2019-9518;en: Some HTTP/2 implementations are vulnerable to a flood of empty frames, potentially leading to a denial of service. The attacker sends a stream of frames with an empty payload and without the end-of-stream flag. These frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The peer spends time processing each frame disproportionate to attack bandwidth. This can consume excess CPU.;FALSE;;Swift;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:apple:swiftnio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-08-13T21:15Z
1708;1070691;apple/swift-nio;CVE-2019-9511;en: Some HTTP/2 implementations are vulnerable to window size manipulation and stream prioritization manipulation, potentially leading to a denial of service. The attacker requests a large amount of data from a specified resource over multiple streams. They manipulate window size and stream priority to force the server to queue the data in 1-byte chunks. Depending on how efficiently this data is queued, this can consume excess CPU, memory, or both.;FALSE;;Swift;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:apple:swiftnio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-08-13T21:15Z
1719;1070763;apple/swift-nio;CVE-2019-9513;en: Some HTTP/2 implementations are vulnerable to resource loops, potentially leading to a denial of service. The attacker creates multiple request streams and continually shuffles the priority of the streams in a way that causes substantial churn to the priority tree. This can consume excess CPU.;FALSE;;Swift;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:apple:swiftnio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-08-13T21:15Z
1730;1070691;apple/swift-nio;CVE-2019-9516;en: Some HTTP/2 implementations are vulnerable to a header leak, potentially leading to a denial of service. The attacker sends a stream of headers with a 0-length header name and 0-length header value, optionally Huffman encoded into 1-byte or greater headers. Some implementations allocate memory for these headers and keep the allocation alive until the session dies. This can consume excess memory.;FALSE;;Swift;;;;;;;;;MEDIUM;LOW;NONE;NONE;cpe:2.3:a:apple:swiftnio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-08-13T21:15Z
1741;1070778;apple/swift-nio;CVE-2019-9514;en: Some HTTP/2 implementations are vulnerable to a reset flood, potentially leading to a denial of service. The attacker opens a number of streams and sends an invalid request over each stream that should solicit a stream of RST_STREAM frames from the peer. Depending on how the peer queues the RST_STREAM frames, this can consume excess memory, CPU, or both.;FALSE;;Swift;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:apple:swiftnio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-08-13T21:15Z
1752;1070763;apple/swift-nio;CVE-2019-9512;en: Some HTTP/2 implementations are vulnerable to ping floods, potentially leading to a denial of service. The attacker sends continual pings to an HTTP/2 peer, causing the peer to build an internal queue of responses. Depending on how efficiently this data is queued, this can consume excess CPU, memory, or both.;FALSE;;Swift;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:apple:swiftnio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-08-13T21:15Z
1763;1070763;apple/swift-nio;CVE-2019-9515;en: Some HTTP/2 implementations are vulnerable to a settings flood, potentially leading to a denial of service. The attacker sends a stream of SETTINGS frames to the peer. Since the RFC requires that the peer reply with one acknowledgement per SETTINGS frame, an empty SETTINGS frame is almost equivalent in behavior to a ping. Depending on how efficiently this data is queued, this can consume excess CPU, memory, or both.;FALSE;;Swift;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:apple:swiftnio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-08-13T21:15Z
1774;1070752;apple/swift-nio;CVE-2018-4281;en: In SwiftNIO before 1.8.0, a buffer overflow was addressed with improved size validation.;FALSE;;Swift;;;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:apple:swiftnio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2019-01-11T18:29Z
1798;1205712;libimobiledevice/libusbmuxd;CVE-2016-5104;en: The socket_create function in common/socket.c in libimobiledevice and libusbmuxd allows remote attackers to bypass intended access restrictions and communicate with services on iOS devices by connecting to an IPv4 TCP socket.;TRUE;C;C;common/socket.c;socket_create;;;;;;;MEDIUM;NONE;NONE;NONE;cpe:2.3:a:libimobiledevice:libusbmuxd:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;LOW;2016-06-13T14:59Z
1800;864974;azure/azure-umqtt-c;CVE-2019-5917;en: azure-umqtt-c (available through GitHub prior to 2017 October 6) allows remote attackers to cause a denial of service via unspecified vectors.;TRUE;C;C;;azure-umqtt-c;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:microsoft:azure-umqtt-c:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-03-12T22:29Z
1823;859204;grpc/grpc;CVE-2020-7768;"en: The package grpc before 1.24.4; the package @grpc/grpc-js before 1.1.8 are vulnerable to Prototype Pollution via loadPackageDefinition.";TRUE;JavaScript;C++;;loadPackageDefinition;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:grpc:grpc:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2020-11-11T11:15Z
1833;858386;aomediacodec/libavif;CVE-2020-36407;en: libavif 0.8.0 and 0.8.1 has an out-of-bounds write in avifDecoderDataFillImageGrid.;TRUE;C;C;;avifDecoderDataFillImageGrid;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:aomedia:libavif:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2021-07-01T03:15Z
1835;882118;flif-hub/flif;CVE-2018-11507;en: An issue was discovered in Free Lossless Image Format (FLIF) 0.3. An attacker can trigger a long loop in image_load_pnm in image/image-pnm.cpp.;TRUE;C++;C++;image/image-pnm.cpp;image_load_pnm;;;;;;;MEDIUM;NONE;REQUIRED;NONE;cpe:2.3:a:flif:flif:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2018-05-28T04:29Z
1836;882118;flif-hub/flif;CVE-2018-12109;en: An issue was discovered in Free Lossless Image Format (FLIF) 0.3. The TransformPaletteC<FileIO>::process function in transform/palette_C.hpp allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted PAM image file.;TRUE;C++;C++;transform/palette_C.hpp;TransformPaletteC<FileIO>::process;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:flif:flif:*:*:*:*:*:*:*:*;LOW;UNCHANGED;LOCAL;HIGH;2018-06-11T13:29Z
1837;882118;flif-hub/flif;CVE-2018-14876;en: An issue was discovered in image_save_png in image/image-png.cpp in Free Lossless Image Format (FLIF) 0.3. Attackers can trigger a longjmp that leads to an uninitialized stack frame after a libpng error concerning the IHDR image width.;TRUE;C++;C++;image/image-png.cpp;image_save_png;;;;;;;MEDIUM;NONE;REQUIRED;NONE;cpe:2.3:a:flif:flif:*:*:*:*:*:*:*:*;LOW;UNCHANGED;LOCAL;NONE;2018-08-03T00:29Z
1838;882118;flif-hub/flif;CVE-2017-14232;en: The read_chunk function in flif-dec.cpp in Free Lossless Image Format (FLIF) 0.3 allows remote attackers to cause a denial of service (invalid memory read and application crash) via a crafted flif file.;TRUE;C++;C++;flif-dec.cpp;read_chunk;;;;;;;MEDIUM;NONE;REQUIRED;NONE;cpe:2.3:a:flif:flif:*:*:*:*:*:*:*:*;LOW;UNCHANGED;LOCAL;NONE;2019-08-15T17:15Z
1839;882118;flif-hub/flif;CVE-2018-10971;en: An issue was discovered in Free Lossless Image Format (FLIF) 0.3. The Plane function in image/image.hpp allows remote attackers to cause a denial of service (attempted excessive memory allocation) via a crafted file.;TRUE;C++;C++;image/image.hpp;Plane;;;;;;;MEDIUM;NONE;REQUIRED;NONE;cpe:2.3:a:flif:flif:*:*:*:*:*:*:*:*;LOW;UNCHANGED;LOCAL;NONE;2018-05-10T15:29Z
1840;882118;flif-hub/flif;CVE-2019-14373;en: An issue was discovered in image_save_png in image/image-png.cpp in Free Lossless Image Format (FLIF) 0.3. Attackers can trigger a heap-based buffer over-read in libpng via a crafted flif file.;TRUE;C++;C++;image/image-png.cpp;image_save_png;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:flif:flif:*:*:*:*:*:*:*:*;LOW;UNCHANGED;LOCAL;HIGH;2019-07-28T19:15Z
1841;1069956;apple/swift-nio-extras;CVE-2020-9840;en: In SwiftNIO Extras before 1.4.1, a logic issue was addressed with improved restrictions.;FALSE;;Swift;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:apple:nioextras:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2020-05-11T20:15Z
1857;1265828;redis/hiredis;CVE-2020-7105;en: async.c and dict.c in libhiredis.a in hiredis through 0.14.0 allow a NULL pointer dereference because malloc return values are unchecked.;TRUE;C;C;async.c, dict.c;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:redislabs:hiredis:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2020-01-16T04:15Z
1875;186824;mailcore/mailcore2;CVE-2020-15953;"en: LibEtPan through 1.9.4, as used in MailCore 2 through 0.6.3 and other products, has a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a ""begin TLS"" response, the client reads additional data (e.g., from a meddler-in-the-middle attacker) and evaluates it in a TLS context, aka ""response injection.""";FALSE;;C++;;;;;;;;;HIGH;NONE;NONE;HIGH;cpe:2.3:a:libetpan_project:libetpan:*:*:*:*:*:*:*:*;HIGH;UNCHANGED;NETWORK;HIGH;2020-07-27T07:15Z
1877;1078425;dinhviethoa/libetpan;CVE-2020-15953;"en: LibEtPan through 1.9.4, as used in MailCore 2 through 0.6.3 and other products, has a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a ""begin TLS"" response, the client reads additional data (e.g., from a meddler-in-the-middle attacker) and evaluates it in a TLS context, aka ""response injection.""";FALSE;;C;;;;;;;;;HIGH;NONE;NONE;HIGH;cpe:2.3:a:libetpan_project:libetpan:*:*:*:*:*:*:*:*;HIGH;UNCHANGED;NETWORK;HIGH;2020-07-27T07:15Z
1900;1078331;dinhviethoa/libetpan;CVE-2017-8825;en: A null dereference vulnerability has been found in the MIME handling component of LibEtPan before 1.8, as used in MailCore and MailCore 2. A crash can occur in low-level/imf/mailimf.c during a failed parse of a Cc header containing multiple e-mail addresses.;TRUE;C;C;low-level/imf/mailimf.c;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:libetpan_project:libetpan:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2017-05-08T16:29Z
1909;43052;daltoniam/starscream;CVE-2017-5887;"en: WebSocket.swift in Starscream before 2.0.4 allows an SSL Pinning bypass because pinning occurs in the stream function (this is too late; pinning should occur in the initStreamsWithData function).";TRUE;Swift;Swift;WebSocket.swift;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:starscream_project:starscream:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2017-04-06T14:59Z
1931;43065;daltoniam/starscream;CVE-2017-7192;en: WebSocket.swift in Starscream before 2.0.4 allows an SSL Pinning bypass because of incorrect management of the certValidated variable (it can be set to true but cannot be set to false).;TRUE;Swift;Swift;WebSocket.swift;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:starscream_project:starscream:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2017-04-06T14:59Z
1953;1187931;leethomason/tinyxml2;CVE-2018-11210;en: ** DISPUTED ** TinyXML2 6.2.0 has a heap-based buffer over-read in the XMLDocument::Parse function in libtinyxml2.so. NOTE: The tinyxml2 developers have determined that the reported overflow is due to improper use of the library and not a vulnerability in tinyxml2.;TRUE;C++;C++;libtinyxml2.so.;XMLDocument::Parse;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:tinyxml2_project:tinyxml2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2018-05-16T15:29Z
1954;1073252;eclipse/mosquitto;CVE-2021-34434;en: In Eclipse Mosquitto versions 2.0 to 2.0.11, when using the dynamic security plugin, if the ability for a client to make subscriptions on a topic is revoked when a durable client is offline, then existing subscriptions for that client are not revoked.;FALSE;;C;;;;;;;;;MEDIUM;NONE;NONE;LOW;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-08-30T20:15Z
1958;1073205;eclipse/mosquitto;CVE-2021-41039;en: In versions 1.6 to 2.0.11 of Eclipse Mosquitto, an MQTT v5 client connecting with a large number of user-property properties could cause excessive CPU usage, leading to a loss of performance and possible denial of service.;FALSE;;C;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-12-01T20:15Z
1978;1073077;eclipse/mosquitto;CVE-2017-7655;en: In Eclipse Mosquitto version from 1.0 to 1.4.15, a Null Dereference vulnerability was found in the Mosquitto library which could lead to crashes for those applications using the library.;FALSE;;C;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-03-27T20:29Z
1998;1073136;eclipse/mosquitto;CVE-2019-11779;en: In Eclipse Mosquitto 1.5.0 to 1.6.5 inclusive, if a malicious MQTT client sends a SUBSCRIBE packet containing a topic that consists of approximately 65400 or more '/' characters, i.e. the topic hierarchy separator, then a stack overflow will occur.;FALSE;;C;;;;;;;;;MEDIUM;LOW;NONE;NONE;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-09-19T14:15Z
2016;1073077;eclipse/mosquitto;CVE-2021-34432;en: In Eclipse Mosquitto versions 2.07 and earlier, the server will crash if the client tries to send a PUBLISH packet with topic length = 0.;FALSE;;C;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-07-27T16:15Z
2077;1073178;eclipse/mosquitto;CVE-2021-34431;en: In Eclipse Mosquitto version 1.6 to 2.0.10, if an authenticated client that had connected with MQTT v5 sent a crafted CONNECT message to the broker a memory leak would occur, which could be used to provide a DoS attack against the broker.;FALSE;;C;;;;;;;;;MEDIUM;LOW;NONE;NONE;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-07-22T14:15Z
2104;1073209;eclipse/mosquitto;CVE-2021-28166;en: In Eclipse Mosquitto version 2.0.0 to 2.0.9, if an authenticated client that had connected with MQTT v5 sent a crafted CONNACK message to the broker, a NULL pointer dereference would occur.;FALSE;;C;;;;;;;;;MEDIUM;LOW;NONE;NONE;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-04-07T19:15Z
2114;1073133;eclipse/mosquitto;CVE-2018-12546;en: In Eclipse Mosquitto version 1.0 to 1.5.5 (inclusive) when a client publishes a retained message to a topic, then has its access to that topic revoked, the retained message will still be published to clients that subscribe to that topic in the future. In some applications this may result in clients being able cause effects that would otherwise not be allowed.;FALSE;;C;;;;;;;;;MEDIUM;LOW;NONE;NONE;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2019-03-27T18:29Z
2140;1073133;eclipse/mosquitto;CVE-2018-20145;en: Eclipse Mosquitto 1.5.x before 1.5.5 allows ACL bypass: if the option per_listener_settings was set to true, and the default listener was in use, and the default listener specified an acl_file, then the acl file was being ignored.;FALSE;;C;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2018-12-13T20:29Z
2145;1073165;eclipse/mosquitto;CVE-2019-11778;en: If an MQTT v5 client connects to Eclipse Mosquitto versions 1.6.0 to 1.6.4 inclusive, sets a last will and testament, sets a will delay interval, sets a session expiry interval, and the will delay interval is set longer than the session expiry interval, then a use after free error occurs, which has the potential to cause a crash in some situations.;FALSE;;C;;;;;;;;;MEDIUM;LOW;NONE;NONE;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;LOW;2019-09-18T23:15Z
2150;1073077;eclipse/mosquitto;CVE-2018-12551;en: When Eclipse Mosquitto version 1.0 to 1.5.5 (inclusive) is configured to use a password file for authentication, any malformed data in the password file will be treated as valid. This typically means that the malformed data becomes a username and no password. If this occurs, clients can circumvent authentication and get access to the broker by using the malformed username. In particular, a blank line will be treated as a valid empty username. Other security measures are unaffected. Users who have only used the mosquitto_passwd utility to create and modify their password files are unaffected by this vulnerability.;FALSE;;C;;;;;;;;;HIGH;NONE;NONE;HIGH;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;HIGH;UNCHANGED;NETWORK;HIGH;2019-03-27T18:29Z
2176;1073084;eclipse/mosquitto;CVE-2018-12550;en: When Eclipse Mosquitto version 1.0 to 1.5.5 (inclusive) is configured to use an ACL file, and that ACL file is empty, or contains only comments or blank lines, then Mosquitto will treat this as though no ACL file has been defined and use a default allow policy. The new behaviour is to have an empty ACL file mean that all access is denied, which is not a useful configuration but is not unexpected.;FALSE;;C;;;;;;;;;HIGH;NONE;NONE;HIGH;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;HIGH;UNCHANGED;NETWORK;HIGH;2019-03-27T18:29Z
2202;1073125;eclipse/mosquitto;CVE-2018-12543;en: In Eclipse Mosquitto versions 1.5 to 1.5.2 inclusive, if a message is published to Mosquitto that has a topic starting with $, but that is not $SYS, e.g. $test/test, then an assert is triggered that should otherwise not be reachable and Mosquitto will exit.;FALSE;;C;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2018-11-15T15:29Z
2205;1073108;eclipse/mosquitto;CVE-2017-7652;en: In Eclipse Mosquitto 1.4.14, if a Mosquitto instance is set running with a configuration file, then sending a HUP signal to server triggers the configuration to be reloaded from disk. If there are lots of clients connected so that there are no more file descriptors/sockets available (default limit typically 1024 file descriptors on Linux), then opening the configuration file will fail.;FALSE;;C;;;;;;;;;HIGH;LOW;NONE;HIGH;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;HIGH;UNCHANGED;NETWORK;HIGH;2018-04-25T13:29Z
2206;1073108;eclipse/mosquitto;CVE-2017-7651;en: In Eclipse Mosquitto 1.4.14, a user can shutdown the Mosquitto server simply by filling the RAM memory with a lot of connections with large payload. This can be done without authentications if occur in connection phase of MQTT protocol.;FALSE;;C;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2018-04-24T14:29Z
2207;1073055;eclipse/mosquitto;CVE-2017-7650;en: In Mosquitto before 1.4.12, pattern based ACLs can be bypassed by clients that set their username/client id to '#' or '+'. This allows locally or remotely connected clients to access MQTT topics that they do have the rights to. The same issue may be present in third party authentication/access control plugins for Mosquitto.;FALSE;;C;;;;;;;;;MEDIUM;LOW;NONE;HIGH;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2017-09-11T16:29Z
2223;1073108;eclipse/mosquitto;CVE-2017-7654;en: In Eclipse Mosquitto 1.4.15 and earlier, a Memory Leak vulnerability was found within the Mosquitto Broker. Unauthenticated clients can send crafted CONNECT packets which could cause a denial of service in the Mosquitto Broker.;FALSE;;C;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2018-06-05T20:29Z
2243;1073077;eclipse/mosquitto;CVE-2017-7653;en: The Eclipse Mosquitto broker up to version 1.4.15 does not reject strings that are not valid UTF-8. A malicious client could cause other clients that do reject invalid UTF-8 strings to disconnect themselves from the broker by sending a topic string which is not valid UTF-8, and so cause a denial of service for the clients.;FALSE;;C;;;;;;;;;MEDIUM;LOW;NONE;NONE;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;HIGH;UNCHANGED;NETWORK;NONE;2018-06-05T20:29Z
2263;1073095;eclipse/mosquitto;CVE-2017-9868;en: In Mosquitto through 1.4.12, mosquitto.db (aka the persistence file) is world readable, which allows local users to obtain sensitive MQTT topic information.;FALSE;;C;;;;;;;;;MEDIUM;LOW;NONE;HIGH;cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*;LOW;UNCHANGED;LOCAL;NONE;2017-06-25T14:29Z
2280;1267229;strukturag/libheif;CVE-2020-23109;en: Buffer overflow vulnerability in function convert_colorspace in heif_colorconversion.cc in libheif v1.6.2, allows attackers to cause a denial of service and disclose sensitive information, via a crafted HEIF file.;TRUE;C++;C++;heif_colorconversion.cc;convert_colorspace;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:struktur:libheif:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-11-03T17:15Z
2281;1267216;strukturag/libheif;CVE-2020-19498;en: Floating point exception in function Fraction in libheif 1.4.0, allows attackers to cause a Denial of Service or possibly other unspecified impacts.;TRUE;C++;C++;;Fraction;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:struktur:libheif:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2021-07-21T18:15Z
2282;1267216;strukturag/libheif;CVE-2020-19499;en: An issue was discovered in heif::Box_iref::get_references in libheif 1.4.0, allows attackers to cause a Denial of Service or possibly other unspecified impact due to an invalid memory read.;TRUE;C++;C++;;heif::Box_iref::get_references;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:struktur:libheif:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2021-07-21T18:15Z
2283;1267216;strukturag/libheif;CVE-2019-11471;en: libheif 1.4.0 has a use-after-free in heif::HeifContext::Image::set_alpha_channel in heif_context.h because heif_context.cc mishandles references to non-existing alpha images.;TRUE;C++;C++;heif_context.h;heif::HeifContext::Image::set_alpha_channel;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:struktur:libheif:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2019-04-23T14:29Z
2284;1318263;webmproject/libwebp;CVE-2018-25012;en: A flaw was found in libwebp in versions before 1.0.1. An out-of-bounds read was found in function WebPMuxCreateInternal. The highest threat from this vulnerability is to data confidentiality and to the service availability.;TRUE;C;C;;WebPMuxCreateInternal;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:webmproject:libwebp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-05-21T17:15Z
2316;1318336;webmproject/libwebp;CVE-2018-25013;en: A flaw was found in libwebp in versions before 1.0.1. An out-of-bounds read was found in function ShiftBytes. The highest threat from this vulnerability is to data confidentiality and to the service availability.;TRUE;C;C;;ShiftBytes;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:webmproject:libwebp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-05-21T17:15Z
2348;1318348;webmproject/libwebp;CVE-2020-36328;en: A flaw was found in libwebp in versions before 1.0.1. A heap-based buffer overflow in function WebPDecodeRGBInto is possible due to an invalid check for buffer size. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.;TRUE;C;C;;WebPDecodeRGBInto;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:webmproject:libwebp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2021-05-21T17:15Z
2380;1318356;webmproject/libwebp;CVE-2020-36329;en: A flaw was found in libwebp in versions before 1.0.1. A use-after-free was found due to a thread being killed too early. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.;FALSE;;C;;;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:webmproject:libwebp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2021-05-21T17:15Z
2412;1318299;webmproject/libwebp;CVE-2020-36331;en: A flaw was found in libwebp in versions before 1.0.1. An out-of-bounds read was found in function ChunkAssignData. The highest threat from this vulnerability is to data confidentiality and to the service availability.;TRUE;C;C;;ChunkAssignData;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:webmproject:libwebp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-05-21T17:15Z
2444;1318287;webmproject/libwebp;CVE-2018-25010;en: A flaw was found in libwebp in versions before 1.0.1. An out-of-bounds read was found in function ApplyFilter. The highest threat from this vulnerability is to data confidentiality and to the service availability.;TRUE;C;C;;ApplyFilter;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:webmproject:libwebp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-05-21T17:15Z
2476;1318287;webmproject/libwebp;CVE-2018-25011;en: A flaw was found in libwebp in versions before 1.0.1. A heap-based buffer overflow was found in PutLE16(). The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.;TRUE;C;C;;PutLE16();;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:webmproject:libwebp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2021-05-21T17:15Z
2508;1318356;webmproject/libwebp;CVE-2018-25009;en: A flaw was found in libwebp in versions before 1.0.1. An out-of-bounds read was found in function WebPMuxCreateInternal. The highest threat from this vulnerability is to data confidentiality and to the service availability.;TRUE;C;C;;WebPMuxCreateInternal;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:webmproject:libwebp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-05-21T17:15Z
2540;1318340;webmproject/libwebp;CVE-2018-25014;en: A flaw was found in libwebp in versions before 1.0.1. An unitialized variable is used in function ReadSymbol. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.;TRUE;C;C;;ReadSymbol;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:webmproject:libwebp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2021-05-21T17:15Z
2572;1318348;webmproject/libwebp;CVE-2020-36332;en: A flaw was found in libwebp in versions before 1.0.1. When reading a file libwebp allocates an excessive amount of memory. The highest threat from this vulnerability is to the service availability.;FALSE;;C;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:webmproject:libwebp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-05-21T17:15Z
2604;1318255;webmproject/libwebp;CVE-2020-36330;en: A flaw was found in libwebp in versions before 1.0.1. An out-of-bounds read was found in function ChunkVerifyAndAssign. The highest threat from this vulnerability is to data confidentiality and to the service availability.;TRUE;C;C;;ChunkVerifyAndAssign;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:webmproject:libwebp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-05-21T17:15Z
2636;1318279;webmproject/libwebp;CVE-2016-9085;en: Multiple integer overflows in libwebp allows attackers to have unspecified impact via unknown vectors.;FALSE;;C;;;;;;;;;LOW;LOW;NONE;NONE;cpe:2.3:a:webmproject:libwebp:*:*:*:*:*:*:*:*;LOW;UNCHANGED;LOCAL;NONE;2017-02-03T15:59Z
2659;1318320;webmproject/libwebp;CVE-2016-9969;en: In libwebp 0.5.1, there is a double free bug in libwebpmux.;FALSE;;C;;;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:webmproject:libwebp:*:*:*:*:*:*:*:*;HIGH;UNCHANGED;NETWORK;HIGH;2019-05-23T18:29Z
2660;864462;azure/azure-iot-sdk-c;CVE-2020-17002;en: Azure SDK for C Security Feature Bypass Vulnerability;FALSE;;C;;;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:microsoft:c_sdk_for_azure_iot:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2020-12-10T00:15Z
2664;10978;google/protobuf;CVE-2015-5237;en: protobuf allows remote authenticated attackers to cause a heap-based buffer overflow.;FALSE;;C++;;;;;;;;;HIGH;LOW;NONE;HIGH;cpe:2.3:a:google:protobuf:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2017-09-25T17:29Z
2689;186920;mailcore/mailcore2;CVE-2021-26911;en: core/imap/MCIMAPSession.cpp in Canary Mail before 3.22 has Missing SSL Certificate Validation for IMAP in STARTTLS mode.;TRUE;C++;C++;core/imap/MCIMAPSession.cpp ;;;;;;;;HIGH;NONE;NONE;HIGH;cpe:2.3:a:libmailcore:mailcore2:*:*:*:*:*:*:*:*;HIGH;UNCHANGED;NETWORK;HIGH;2021-02-17T21:15Z
2690;1070350;apple/swift-nio-ssl;CVE-2019-8849;en: The issue was addressed by signaling that an executable stack is not required. This issue is fixed in SwiftNIO SSL 2.4.1. A SwiftNIO application using TLS may be able to execute arbitrary code.;FALSE;;C;;;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:apple:swiftnio_ssl:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2019-12-18T18:15Z
2710;1205176;libgit2/libgit2;CVE-2020-12278;en: An issue was discovered in libgit2 before 0.28.4 and 0.9x before 0.99.0. path.c mishandles equivalent filenames that exist because of NTFS Alternate Data Streams. This may allow remote code execution when cloning a repository. This issue is similar to CVE-2019-1352.;TRUE;C;C;path.c;;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:libgit2:libgit2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2020-04-27T17:15Z
2783;1205155;libgit2/libgit2;CVE-2020-12279;en: An issue was discovered in libgit2 before 0.28.4 and 0.9x before 0.99.0. checkout.c mishandles equivalent filenames that exist because of NTFS short names. This may allow remote code execution when cloning a repository. This issue is similar to CVE-2019-1353.;FALSE;;C;;;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:libgit2:libgit2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2020-04-27T17:15Z
2856;1205196;libgit2/libgit2;CVE-2018-10887;en: A flaw was found in libgit2 before version 0.27.3. It has been discovered that an unexpected sign extension in git_delta_apply function in delta.c file may lead to an integer overflow which in turn leads to an out of bound read, allowing to read before the base object. An attacker may use this flaw to leak memory addresses or cause a Denial of Service.;TRUE;C;C; delta.c;git_delta_apply;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:libgit2:libgit2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2018-07-10T14:29Z
2929;1205269;libgit2/libgit2;CVE-2018-10888;en: A flaw was found in libgit2 before version 0.27.3. A missing check in git_delta_apply function in delta.c file, may lead to an out-of-bound read while reading a binary delta file. An attacker may use this flaw to cause a Denial of Service.;TRUE;C;C;delta.c;git_delta_apply;;;;;;;MEDIUM;NONE;REQUIRED;NONE;cpe:2.3:a:libgit2:libgit2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2018-07-10T14:29Z
2990;1205346;libgit2/libgit2;CVE-2018-15501;"en: In ng_pkt in transports/smart_pkt.c in libgit2 before 0.26.6 and 0.27.x before 0.27.4, a remote attacker can send a crafted smart-protocol ""ng"" packet that lacks a '\0' byte to trigger an out-of-bounds read that leads to DoS.";TRUE;C;C;transports/smart_pkt.c;ng_pkt;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:libgit2:libgit2:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2018-08-18T02:29Z
3049;979999;akheron/jansson;CVE-2020-36325;en: ** DISPUTED ** An issue was discovered in Jansson through 2.13.1. Due to a parsing error in json_loads, there's an out-of-bounds read-access bug. NOTE: the vendor reports that this only occurs when a programmer fails to follow the API specification.;TRUE;C;C;;json_loads;;;; only occurs when a programmer fails to follow the API specification.;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:jansson_project:jansson:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-04-26T18:15Z
3079;979925;akheron/jansson;CVE-2016-4425;en: Jansson 2.7 and earlier allows context-dependent attackers to cause a denial of service (deep recursion, stack consumption, and crash) via crafted JSON data.;FALSE;;C;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:jansson_project:jansson:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2016-05-17T14:08Z
3102;979821;akheron/jansson;CVE-2013-6401;en: Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.;FALSE;;C;;;;;;;;;;;;;cpe:2.3:a:jansson_project:jansson:*:*:*:*:*:*:*:*;;;;;2014-03-21T01:04Z
3122;1050873;aubio/aubio;CVE-2018-14523;en: An issue was discovered in aubio 0.4.6. A buffer over-read can occur in new_aubio_pitchyinfft in pitch/pitchyinfft.c, as demonstrated by aubionotes.;TRUE;C;C;pitch/pitchyinfft.c;new_aubio_pitchyinfft;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:aubio:aubio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2018-07-23T08:29Z
3123;1050833;aubio/aubio;CVE-2018-19802;en: aubio v0.4.0 to v0.4.8 has a new_aubio_onset NULL pointer dereference.;TRUE;C;C;;new_aubio_onset;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:aubio:aubio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-06-07T17:29Z
3132;1050873;aubio/aubio;CVE-2018-19801;en: aubio v0.4.0 to v0.4.8 has a NULL pointer dereference in new_aubio_filterbank via invalid n_filters.;TRUE;C;C;;new_aubio_filterbank;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:aubio:aubio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2019-06-07T17:29Z
3141;1050861;aubio/aubio;CVE-2018-19800;en: aubio v0.4.0 to v0.4.8 has a Buffer Overflow in new_aubio_tempo.;TRUE;C;C;;new_aubio_tempo;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:aubio:aubio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2019-06-07T17:29Z
3150;1050873;aubio/aubio;CVE-2018-14522;en: An issue was discovered in aubio 0.4.6. A SEGV signal can occur in aubio_pitch_set_unit in pitch/pitch.c, as demonstrated by aubionotes.;TRUE;C;C;pitch/pitch.c;aubio_pitch_set_unit;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:aubio:aubio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2018-07-23T08:29Z
3151;1050873;aubio/aubio;CVE-2018-14521;en: An issue was discovered in aubio 0.4.6. A SEGV signal can occur in aubio_source_avcodec_readframe in io/source_avcodec.c, as demonstrated by aubiomfcc.;TRUE;C;C;io/source_avcodec.c;aubio_source_avcodec_readframe;;;;;;;HIGH;NONE;REQUIRED;HIGH;cpe:2.3:a:aubio:aubio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2018-07-23T08:29Z
3152;1050873;aubio/aubio;CVE-2017-17555;en: The swri_audio_convert function in audioconvert.c in FFmpeg libswresample through 3.0.101, as used in FFmpeg 3.4.1, aubio 0.4.6, and other products, allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted audio file.;TRUE;C;C;audioconvert.c;swri_audio_convert;;;;;;;MEDIUM;NONE;REQUIRED;NONE;cpe:2.3:a:aubio:aubio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2017-12-12T01:29Z
3153;1050873;aubio/aubio;CVE-2017-17554;en: A NULL pointer dereference (DoS) Vulnerability was found in the function aubio_source_avcodec_readframe in io/source_avcodec.c of aubio 0.4.6, which may lead to DoS when playing a crafted audio file.;TRUE;C;C;io/source_avcodec.c;aubio_source_avcodec_readframe;;;;;;;MEDIUM;NONE;REQUIRED;NONE;cpe:2.3:a:aubio:aubio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;LOCAL;NONE;2017-12-12T01:29Z
3154;1050873;aubio/aubio;CVE-2017-17054;en: In aubio 0.4.6, a divide-by-zero error exists in the function new_aubio_source_wavread() in source_wavread.c, which may lead to DoS when playing a crafted audio file.;TRUE;C;C;source_wavread.c;new_aubio_source_wavread();;;;;;;MEDIUM;NONE;REQUIRED;NONE;cpe:2.3:a:aubio:aubio:*:*:*:*:*:*:*:*;LOW;UNCHANGED;LOCAL;NONE;2017-11-29T07:29Z
3155;1273481;facebook/folly;CVE-2021-24036;en: Passing an attacker controlled size when creating an IOBuf could cause integer overflow, leading to an out of bounds write on the heap with the possibility of remote code execution. This issue affects versions of folly prior to v2021.07.22.00. This issue affects HHVM versions prior to 4.80.5, all versions between 4.81.0 and 4.102.1, all versions between 4.103.0 and 4.113.0, and versions 4.114.0, 4.115.0, 4.116.0, 4.117.0, 4.118.0 and 4.118.1.;TRUE;C++;C++;IOBuf;;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:facebook:folly:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2021-07-23T01:15Z
3157;1100104;facebook/folly;CVE-2019-11934;en: Improper handling of close_notify alerts can result in an out-of-bounds read in AsyncSSLSocket. This issue affects folly prior to v2019.11.04.00.;TRUE;C++;C++;AsyncSSLSocket;;;;;;;;CRITICAL;NONE;NONE;HIGH;cpe:2.3:a:facebook:folly:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2019-12-04T17:16Z
3159;221554;apache/cordova-ios;CVE-2014-0072;en: ios/CDVFileTransfer.m in the Apache Cordova File-Transfer standalone plugin (org.apache.cordova.file-transfer) before 0.4.2 for iOS and the File-Transfer plugin for iOS from Cordova 2.4.0 through 2.9.0 might allow remote attackers to spoof SSL servers by leveraging a default value of true for the trustAllHosts option.;TRUE;Objective-C;JavaScript;ios/CDVFileTransfer.m;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:apache:cordova_file_transfer:*:*:*:*:*:iphone_os:*:*;LOW;UNCHANGED;NETWORK;HIGH;2017-10-30T19:29Z
3171;1102453;ethereum/go-ethereum;CVE-2021-43668;"en: Go-Ethereum 1.10.9 nodes crash (denial of service) after receiving a serial of messages and cannot be recovered. They will crash with ""runtime error: invalid memory address or nil pointer dereference"" and arise a SEGV signal.";FALSE;;Go;;;;;;;;;MEDIUM;LOW;NONE;NONE;cpe:2.3:a:ethereum:go_ethereum:*:*:*:*:*:*:*:*;LOW;UNCHANGED;LOCAL;NONE;2021-11-18T16:15Z
3172;1101874;ethereum/go-ethereum;CVE-2021-41173;en: Go Ethereum is the official Golang implementation of the Ethereum protocol. Prior to version 1.10.9, a vulnerable node is susceptible to crash when processing a maliciously crafted message from a peer. Version v1.10.9 contains patches to the vulnerability. There are no known workarounds aside from upgrading.;FALSE;;Go;;;;;;;;;MEDIUM;LOW;REQUIRED;NONE;cpe:2.3:a:ethereum:go_ethereum:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-10-26T14:15Z
3213;1101878;ethereum/go-ethereum;CVE-2021-39137;en: go-ethereum is the official Go implementation of the Ethereum protocol. In affected versions a consensus-vulnerability in go-ethereum (Geth) could cause a chain split, where vulnerable versions refuse to accept the canonical chain. Further details about the vulnerability will be disclosed at a later date. A patch is included in the upcoming `v1.10.8` release. No workaround are available.;FALSE;;Go;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:ethereum:go_ethereum:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2021-08-24T16:15Z
3258;1102316;ethereum/go-ethereum;CVE-2020-26265;"en: Go Ethereum, or ""Geth"", is the official Golang implementation of the Ethereum protocol. In Geth from version 1.9.4 and before version 1.9.20 a consensus-vulnerability could cause a chain split, where vulnerable versions refuse to accept the canonical chain. The fix was included in the Paragade release version 1.9.20. No individual workaround patches have been made -- all users are recommended to upgrade to a newer version.";FALSE;;Go;;;;;;;;;MEDIUM;LOW;NONE;NONE;cpe:2.3:a:ethereum:go_ethereum:*:*:*:*:*:*:*:*;HIGH;UNCHANGED;NETWORK;HIGH;2020-12-11T17:15Z
3269;1102200;ethereum/go-ethereum;CVE-2020-26264;"en: Go Ethereum, or ""Geth"", is the official Golang implementation of the Ethereum protocol. In Geth before version 1.9.25 a denial-of-service vulnerability can make a LES server crash via malicious GetProofsV2 request from a connected LES client. This vulnerability only concerns users explicitly enabling les server; disabling les prevents the exploit. The vulnerability was patched in version 1.9.25.";FALSE;;Go;;;;;;;;;MEDIUM;LOW;NONE;NONE;cpe:2.3:a:ethereum:go_ethereum:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2020-12-11T17:15Z
3446;1101941;ethereum/go-ethereum;CVE-2020-26241;"en: Go Ethereum, or ""Geth"", is the official Golang implementation of the Ethereum protocol. This is a Consensus vulnerability in Geth before version 1.9.17 which can be used to cause a chain-split where vulnerable nodes reject the canonical chain. Geth's pre-compiled dataCopy (at 0x00...04) contract did a shallow copy on invocation. An attacker could deploy a contract that writes X to an EVM memory region R, then calls 0x00..04 with R as an argument, then overwrites R to Y, and finally invokes the RETURNDATACOPY opcode. When this contract is invoked, a consensus-compliant node would push X on the EVM stack, whereas Geth would push Y. This is fixed in version 1.9.17.";TRUE;Go;Go;;dataCopy;;;;;;;HIGH;LOW;NONE;NONE;cpe:2.3:a:ethereum:go_ethereum:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2020-11-25T02:15Z
3491;1101883;ethereum/go-ethereum;CVE-2020-26242;"en: Go Ethereum, or ""Geth"", is the official Golang implementation of the Ethereum protocol. In Geth before version 1.9.18, there is a Denial-of-service (crash) during block processing. This is fixed in 1.9.18.";FALSE;;Go;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:ethereum:go_ethereum:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2020-11-25T02:15Z
3536;1101945;ethereum/go-ethereum;CVE-2020-26240;"en: Go Ethereum, or ""Geth"", is the official Golang implementation of the Ethereum protocol. An ethash mining DAG generation flaw in Geth before version 1.9.24 could cause miners to erroneously calculate PoW in an upcoming epoch (estimated early January, 2021). This happened on the ETC chain on 2020-11-06. This issue is relevant only for miners, non-mining nodes are unaffected. This issue is fixed as of 1.9.24";FALSE;;Go;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:ethereum:go_ethereum:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2020-11-25T02:15Z
3581;1101956;ethereum/go-ethereum;CVE-2018-20421;"en: Go Ethereum (aka geth) 1.8.19 allows attackers to cause a denial of service (memory consumption) by rewriting the length of a dynamic array in memory, and then writing data to a single memory location with a large index number, as demonstrated by use of ""assembly { mstore }"" followed by a ""c[0xC800000] = 0xFF"" assignment.";FALSE;;Go;;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:ethereum:go_ethereum:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2018-12-24T03:29Z
3626;1101959;ethereum/go-ethereum;CVE-2018-19184;en: cmd/evm/runner.go in Go Ethereum (aka geth) 1.8.17 allows attackers to cause a denial of service (SEGV) via crafted bytecode.;TRUE;Go;Go;cmd/evm/runner.go;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:ethereum:go_ethereum:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2018-11-12T02:29Z
3671;1101950;ethereum/go-ethereum;CVE-2018-16733;en: In Go Ethereum (aka geth) before 1.8.14, TraceChain in eth/api_tracer.go does not verify that the end block is after the start block.;TRUE;Go;Go;eth/api_tracer.go;;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:ethereum:go_ethereum:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;HIGH;2018-09-08T15:29Z
3716;1101759;ethereum/go-ethereum;CVE-2018-12018;en: The GetBlockHeadersMsg handler in the LES protocol implementation in Go Ethereum (aka geth) before 1.8.11 may lead to an access violation because of an integer signedness error for the array index, which allows attackers to launch a Denial of Service attack by sending a packet with a -1 query.Skip value. The vulnerable remote node would be crashed by such an attack immediately, aka the EPoD (Ethereum Packet of Death) issue.;TRUE;Go;Go;;GetBlockHeadersMsg;;;;;;;HIGH;NONE;NONE;NONE;cpe:2.3:a:ethereum:go_ethereum:*:*:*:*:*:*:*:*;LOW;UNCHANGED;NETWORK;NONE;2018-07-05T02:29Z